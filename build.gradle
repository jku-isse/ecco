plugins {
	id "nebula.ospackage" version "4.5.1"
}

allprojects {
	apply plugin: 'idea'
	apply plugin: 'eclipse'
	group = 'at.jku.isse.ecco'
	//version = '0.1.6'
	version = '0.1.6-' + new java.text.SimpleDateFormat("YYYY-MM-dd", Locale.ENGLISH).format(new Date())
	//version = new java.text.SimpleDateFormat("YYYY.M.d", Locale.ENGLISH).format(new Date())
}

subprojects {
	apply plugin: 'nebula.ospackage'
	apply plugin: 'java'
	apply plugin: 'maven-publish'

	sourceCompatibility = 1.8
	targetCompatibility = 1.8

	repositories {
		mavenCentral()
	}

	dependencies {
		compile 'com.google.guava:guava:18.0'
		testCompile 'org.testng:testng:6.9.6'
	}

	jar {
		manifest {
			attributes("Implementation-Title": project.name, "Implementation-Version": project.version, "Implementation-Vendor": project.group)
		}
	}

	sourceSets {
		integrationTest {
			java {
				compileClasspath += main.output + test.output
				runtimeClasspath += main.output + test.output
				srcDir file('src/integrationTest/java')
			}
			resources {
				srcDir file('src/integrationTest/resources')
				exclude '**/*.java'
			}
		}
	}

	configurations {
		integrationTestCompile.extendsFrom testCompile
		integrationTestRuntime.extendsFrom testRuntime
	}

	test {
		useTestNG() {
			suites 'src/test/resources/testng.xml'
		}
		workingDir = 'src/test/'
		outputs.upToDateWhen { false }
	}
	test.onlyIf {
		new File(getProjectDir(), 'src/test/resources/testng.xml').exists()
	}

	task integrationTest(type: Test, group: 'verification', description: 'Runs the integration tests.') {
		useTestNG() {
			suites 'src/integrationTest/resources/testng.xml'
		}
		workingDir = 'build/'
		classpath = sourceSets.integrationTest.runtimeClasspath
		outputs.upToDateWhen { false }
	}
	integrationTest.onlyIf {
		new File(getProjectDir(), 'src/integrationTest/resources/testng.xml').exists()
	}
	check.dependsOn -= integrationTest

	tasks.withType(Test) {
		reports.html.destination = file("${reporting.baseDir}/${name}")
	}

	idea {
		module {
			testSourceDirs += file('src/integrationTest/java')
			scopes.TEST.plus += [configurations.integrationTestCompile]
			downloadJavadoc = true
			downloadSources = true
		}
	}

	eclipse {
		classpath {
			downloadJavadoc = true
			downloadSources = true
		}
	}

	publishing {
		publications {
			eccoMaven(MavenPublication) {
				groupId project.group
				artifactId project.name
				version project.version

				from project.components.java

				artifact javadocJar {
				}
				artifact sourcesJar {
				}
			}
		}
		repositories {
			maven {
				name 'ECCO'
				description 'ECCO Maven repository.'
				url "$buildDir/maven2"
			}
			maven {
				name 'RootECCO'
				description 'Root ECCO Maven repository.'
				url "$rootProject.buildDir/maven2"
			}
		}
	}

	// # PACKAGING
	ospackage {
		packageName = project.name
		version = project.version
		release = 1
		arch = NOARCH
		os = LINUX

		prefix '/usr/'

		directory('/usr/share/java/ecco')
		directory('/usr/share/java/ecco/lib')

		into('/usr/share/java/') {
			from(project.jar) {
				addParentDirs false
				into 'ecco/'
			}

			from({
				def temp = project.configurations.runtime;
				project.configurations.findAll { it.name.equals("runtime") }.collectMany {
					it.allDependencies
				}.findAll { it instanceof ProjectDependency }.collect {
					it.dependencyProject.configurations.runtime
				}.each { temp = temp - it };
				project.configurations.findAll { it.name.equals("runtime") }.collectMany {
					it.allDependencies
				}.findAll { it instanceof ProjectDependency }.collect { it.dependencyProject.jar.outputs.files }.each {
					temp = temp - it;
				};
				return temp;
			}) {
				addParentDirs false
				into 'ecco/lib/'
			}
		}
	}

	buildRpm {
	}

	buildDeb {
	}

	task rpm(type: Rpm, group: 'packaging') {
	}

	task deb(type: Deb, group: 'packaging') {
	}

	task sourcesJar(type: Jar, group: 'packaging') {
		classifier = 'sources'
		from sourceSets.main.allSource
	}

	task javadocJar(type: Jar, group: 'packaging', dependsOn: javadoc) {
		classifier = 'javadoc'
		from javadoc.destinationDir
	}

	artifacts {
		archives sourcesJar
		archives javadocJar
	}

	task linuxZip(type: Zip, group: 'packaging') {
		classifier = 'linux'
		into(archiveName - ('.' + extension)) {
			from project.jar
			from project.configurations.runtime
		}
	}

	task sourcesZip(type: Zip, group: 'packaging') {
		//compression = Compression.GZIP
		classifier = 'src'
		from projectDir
		include 'src/**/*'
		include 'build.gradle'
	}

	task windowsZip(type: Zip, group: 'packaging') {
		classifier = 'windows'
		into(archiveName - ('.' + extension)) {
			from project.jar
			from project.configurations.runtime
		}
	}

	// # BUNDLING
	task copyJars(type: Copy, dependsOn: project.build) {
		from(project.jar)
		into project.file('build/bundle/')
	}
	task copyDependencies(type: Copy) {
		from(project.configurations.runtime)
		into project.file('build/bundle/lib/')
	}
	task bundle(dependsOn: [copyJars, copyDependencies])

	task depTest {
		def temp = project.configurations.runtime
		project.configurations.findAll { it.name.equals("runtime"); }.collectMany { it.allDependencies }.findAll {
			it instanceof ProjectDependency
		}.collect { it.dependencyProject.jar.outputs.files }.each { println it };
	}
}

task combinedjavadoc(type: Javadoc, group: "documentation") {
	description = 'Generates a global javadoc from all the modules.'
	source project.subprojects.collect { it.sourceSets.main.allJava }
	classpath = files(project.subprojects.collect { it.sourceSets.main.compileClasspath })
	options.memberLevel = JavadocMemberLevel.PRIVATE
	options.links = ['https://docs.oracle.com/javase/8/docs/api/']
	destinationDir = file("${buildDir}/docs/javadoc")
}

task combinedrpm(type: Copy, group: 'packaging') {
	dependsOn subprojects.rpm
	into "$buildDir/distributions/rpm"
	//from project.subprojects.collect { it.rpm.archivePath }
	from subprojects.rpm.archivePath
}

task combineddeb(type: Copy, group: 'packaging') {
	dependsOn subprojects.deb
	into "$buildDir/distributions/deb"
	//from project.subprojects.collect { it.deb.archivePath }
	from subprojects.deb.archivePath
}

task combinedLinuxZip(type: Zip, group: 'packaging') {
	into project.name
	classifier = 'linux'
	from { subprojects.linuxZip.source }
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

task combinedWindowsZip(type: Zip, group: 'packaging') {
	into project.name
	classifier = 'windows'
	//from { subprojects.jar }
	//from { subprojects.configurations.runtime }
	from { subprojects.windowsZip.source }
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

task html(type: Copy, dependsOn: [combinedrpm, combineddeb, combinedLinuxZip, combinedWindowsZip]) {
	from "."
	into "$buildDir"
	include "index.html.template"
	rename { file -> 'index.html' }
	//expand(project: project, rpms: fileTree(dir: combinedrpm.outputs.files[0], include: '*.rpm').files.name, debs: fileTree(dir: combinedrpm.outputs.files[0], include: '*.deb').files.name)
	expand(project: project, windowsZip: combinedWindowsZip.outputs.files[0].name, linuxZip: combinedLinuxZip.outputs.files[0].name, rpms: combinedrpm.outputs.files.filter { file -> file.isDirectory() }.collect { dir ->  fileTree(dir: dir, include: '*.rpm').files.name }.flatten(), debs: combineddeb.outputs.files.filter { file -> file.isDirectory() }.collect { dir ->  fileTree(dir: dir, include: '*.deb').files.name }.flatten())
}

idea {
	project {
		languageLevel = '1.8'
	}
}

task wrapper(type: Wrapper) {
	gradleVersion = '4.4'
}
